# Аналітичний меморандум: Стратегія Bootstrap та відновлення (v3)

Цей документ визначає єдиний протокол холодного старту, рестарту та відновлення даних у системі (схема A→C→B). Основна мета: забезпечити цілісність даних (No Split-Brain), мінімізувати час очікування UI (Warm-up) та гарантувати детермінованість похідних таймфреймів.

## 1. Архітектурна концепція (A→C→B)

- **A (Broker):** Джерело сирих даних (M1 + D1). Всі інші TF є похідними (Derived).
- **C (UDS):** Єдина "вузька талія". Тільки UDS керує станом Disk/Redis.
- **B (UI/API):** Read-only споживач. Блокується до досягнення стану `PRIMECOMPLETE`.

## 2. Алгоритм холодного старту (Cold Start)

Виконується при порожній базі `data_v3` або критичній невідповідності історії.

1. **Discovery (SSOT):** Зчитування `symbols` та `timeframes` виключно з `config.json`.
2. **Паралельний Bootstrap (Broker → Disk):**
    - **D1 Plane:** Пріоритетне завантаження для швидкої побудови денних трендів.
    - **M1 Plane:** Чанкове завантаження (Chunked loading) останніх 2–3 днів (налаштовується через `warmup_bars`).
3. **Derived Rebuild (M1 → HTF):**
    - Після завершення M1-завантаження викликається внутрішній модуль `tools/rebuild_derived.py`.
    - Генерація M5, M15, H1, H4 виконується локально без запитів до брокера (Invariant I1).
4. **Gate & Priming:**
    - `gatecoldstartmultisymbol` блокує API-запити, поки всі 13 символів не пройдуть стадію ребілду.
    - **Redis Priming:** Завантаження останніх хвостів (Tail) з Диску в Redis у межах `redisprimingbudget_s`.

## 3. Рестарт та відновлення (Catch-up)

Виконується при перезапуску системи з наявними даними.

- **Валідація стану:** Перевірка `derivedtail_state.json` та `lastsavedm5open_ms`.
- **Short Pause (< 4h):**
  - `PRIME_FULL` з Redis.
  - Дозавантаження (Catch-up) пропущених M1 барі брокера → оновлення похідних.
- **Long Pause (> 4h або `maxwarmupbars`):**
  - Перехід у режим часткового Bootstrap.
  - Повна синхронізація M1 → Повний Rebuild похідних → Атомарне оновлення `state`.

## 4. Жорсткі інваріанти та Loud Degrade

1. **I3 (Final > Preview):** Результати `rebuild_derived` завжди мають статус `complete=true` і затирають будь-які попередні preview-дані.
2. **I5 (Degraded-but-loud):** Будь-яка помилка під час ребілду або праймінгу виставляє прапор `degraded` у статус-API.
3. **F5 (FXCM Session):** Використання семафора для черги запитів до брокера (D1 пріоритет над M1 чанками).

## 5. Чек-лист імплементації та SLO

- [ ] **Config:** Встановити `redisprimingbudget_s` ≥ обсягу 3-денного хвоста.
- [ ] **Gate:** Реалізувати блокування `/api/bars` до моменту `status.readiness == true`.
- [ ] **Pipeline:** Інтегрувати `rebuild_derived` як функціональний виклик, а не зовнішній скрипт.
- [ ] **State:** Додати атомарний запис `derivedtail_state.json` з контрольною сумою.

### Цілі (SLO)

- **Time-to-first-candle:** Скорочення в 4–5 разів за рахунок локального ребілду.
- **Data Integrity:** 0 випадків змішування старих та нових даних (No Split-Brain).

---
*Документ узгоджено з ADR v3.*

## MODE=DISCOVERY — Аналітичний меморандум: Cold Start системи

Preflight підтвердження: system_current_overview.md і research/ПОВНИЙ АУДИТ.md звірено. ADR-0002 завершено. engine_b = D1-only, m1_poller = M1→H4 via DeriveEngine.

0) INPUT
Ціль: Ідеальний cold start для TradingView-клас UX на 13 символів × 8 TF
SLO: p95 < 200мс time-to-first-candle, no split-brain, no silent fallback
Scope: 5 процесів — connector (D1), tick_publisher, tick_preview, m1_poller, ui
Non-goals: не міняти derive chain, не додавати нові TF/процеси

1) FACTS — Поточна послідовність старту (AS-IS)

Supervisor (app.main --mode all)
 │
 ├─[1] connector         → FXCM login (2-30s) → bootstrap_and_warmup()
 │      ├─ _bootstrap_from_disk()       → disk tail → watermark D1
 │      ├─_prime_redis_from_disk()     → disk→Redis (budget=5s, TFs: M1..D1)
 │      ├─ set_prime_ready()            → Redis prime:ready (TTL=6h)
 │      └─_cold_start_base_from_broker() → FXCM fetch D1 (180 bars)
 │
 ├─[2] tick_preview      → Redis sub (no FXCM needed)
 ├─[3] tick_publisher    → FXCM WS connect
 ├─[4] m1_poller         →_bootstrap_warmup()
 │      ├─ Redis priming M1/M3 (no budget!)
 │      ├─ M1Buffer warmup (10 bars disk)
 │      ├─ DeriveEngine warmup (300 M1 bars → buffer only)
 │      └─ tail_catchup (FXCM fetch gap M1)
 │
 ├─ _wait_for_prime_ready (20s timeout, result IGNORED!)
 └─[5] ui                → _bootstrap_warmup() → disk→RAM (13sym × 8TF)

 1) FAILURE MODEL — 10 сценаріїв відмов

## Сценарій Де виникає Поточна поведінка Severity

F1 FXCM login fail (credentials/network) connector + m1_poller connector: retry loop (exp backoff 10s..3600s); m1_poller: skip tail_catchup, main loop з errors + reconnect кожні 120s HIGH

F2 Redis down при старті всі writer-и connector:_prime_redis_from_disk → has_redis_writer()=False → skip priming; UDS guards повертають None; UI отримує порожні масиви HIGH

F3 DeriveEngine buffers порожні при старті m1_poller warmup_bars(300 M1) буферизує лише M1. Cascade buffers для M5/M15/M30/H1 порожні → перші ~4 години H4 derive не спрацює HIGH

F4 prime_ready gate не спрацює (timeout 20s) supervisor→UI UI стартує з degraded. RAM warmup з disk покриває, але warnings: ["prime_pending"] MEDIUM

F5 m1_poller не сигналізує ready m1_poller M1/M3 Redis priming невидиме для UI gate. UI чекає тільки connector prime_ready MEDIUM

F6 Partial Redis priming (budget 5s вичерпано) connector 13 sym × 8 TF = 104 операцій за 5с. Якщо диск повільний → partial=True → degraded MEDIUM

F7 Watermark=None (новий символ/порожній disk) m1_poller tail_catchup skip → перший бар лише з poll loop (8s delay) MEDIUM

F8 Corrupt JSONL на диску engine_b + m1_poller _bootstrap_from_disk() — без try/except → process crash → supervisor crash ALL HIGH

F9 Broker cold_start fetch fail connector fetch_last_n_tf() — без try/except → cascade crash → supervisor crash ALL HIGH

F10 boot_id collision (rapid restart) engine_b boot_id = time.strftime(...) → якщо два процеси стартують в ту ж секунду, UI може не детектити restart LOW

1) GAP ANALYSIS — Порушені інваріанти

Інваріант Стан Проблема

I1 (UDS вузька талія) PARTIAL engine_b prime і m1_poller prime — паралельно без координації; UI gate бачить тільки connector

I4 (один update-потік) OK —

I5 (degraded-but-loud) PARTIAL _wait_for_prime_ready результат ігнорується — UI стартує як silent degraded

I6 (disk hot-path ban) OK disk тільки на bootstrap

ADR-0002 §8 SLO 4 unchecked redis_priming_budget, API gate blocking, pipeline integration, atomic state write

1) Критичні архітектурні проблеми (ранжовані)

P0 — Відсутня ізоляція відмов у bootstrap

engine_b.py:302-320: bootstrap_and_warmup() — жоден крок не обгорнутий в try/except
engine_b.py:453-543: _cold_start_base_from_broker() → broker fetch без try/except
Crash одного кроку → crash процесу → supervisor crash ALL 5 процесів
Наслідок: один corrupt JSONL файл або network glitch = вся платформа down
P1 — DeriveEngine warmup: cascade buffers порожні

m1_poller.py:870-885: warmup_bars() буферизує лише M1 бари
derive_engine.py:160-180: warmup_bars() фільтрує if bar.tf_s not in DERIVE_CHAIN — тільки M1 (tf_s=60) і M5 (tf_s=300) буфери
Але M5 не подаються на warmup (тільки 300 M1 барів читаються з UDS tf_s=60)
Cascade M5→M15→M30→H1→H4: усі буфери нижче M1 порожні → перший H4 derive через ~4 години
Наслідок: Після рестарту H4/H1/M30/M15 live-свічки не оновлюються 1-4 години
P2 — Дві незалежні Redis priming системи без координації

engine_b: прайміть M5..D1 (8 TFs, budget 5s) → публікує prime:ready
m1_poller: прайміть M1/M3 (2 TFs, без budget) → не публікує prime:ready
UI wait gate: бачить лише connector prime:ready
Наслідок: UI може стартувати до m1_poller priming M1/M3
P3 — Prime ready gate "cosmetic"

main.py:306-309: _wait_for_prime_ready(config_path) → результат не використовується
UI завжди стартує після 20s timeout
Наслідок: gate не є справжнім gate — це лише delay
P4 — Redis priming budget неадекватний

Budget=5s для 13 символів × 8 TF = 104 bootstrap_prime_from_disk() викликів
Кожен виклик: disk read (tail N) + Redis pipeline write → ~50-200мс залежно від tail_n
104 × 100мс = ~10.4с > 5с budget → partial priming гарантовано
TF сортовані за зростанням → D1 (останній) часто не прайміться
P5 — Немає auto-restart process ізоляції

main.py:345-346: exit code != 0 → RuntimeError → supervisor kills ALL
tick_publisher crash (FXCM WS disconnect) → все down
Наслідок: найслабший процес визначає uptime всієї системи

1) GO/NO-GO

GO PATCH — жодна проблема не потребує зміни інваріантів або контрактів. Всі фікси — в межах існуючої架構и (runtime/app layer).

1) ПЛАН — Cold Start Initiative (P-slices)

Initiative: cold_start_hardening
Goal: ідеальний старт 13 символів за ≤30с, resilient до broker/Redis/disk відмов

Slice Ціль LOC est Файли Priority

S1 Error isolation в bootstrap (try/except обгортки) ~80 engine_b.py, m1_poller.py P0

S2 DeriveEngine multi-TF warmup (буферизація M5/M15/M30/H1 з диску) ~60 m1_poller.py, derive_engine.py P0

S3 Unified prime_ready (m1_poller + connector → single gate) ~80 m1_poller.py, engine_b.py, main.py P1

S4 Redis priming budget → adaptive (per-symbol instead of global timer) ~50 engine_b.py, m1_poller.py P1

S5 Supervisor process isolation (restart individual, not crash all) ~100 main.py P2
S6 Boot resilience (broker down → degrade gracefully, not block forever) ~60 engine_b.py, m1_poller.py P1

S7 Config SSOT: prime_ready_timeout, priming_budget → config.json ~30 config.json, main.py, engine_b.py P2

Деталі кожного slice:

S1 — Error isolation в bootstrap

engine_b bootstrap_and_warmup(): обгорнути кожен крок в try/except, зберегти partial результат
engine_b _cold_start_base_from_broker(): try/except навколо broker fetch, degrade-but-loud
m1_poller _bootstrap_warmup(): try/except навколо warmup фаз
Rail: bootstrap crash → процес стартує в degraded mode (polling loop працює), не crash
S2 — DeriveEngine multi-TF warmup

Після warmup_bars(M1), прочитати M5/M15/M30/H1 tail з UDS disk і warmup_bars() для кожного
Розширити warmup_bars(): приймати бари будь-якого source TF з DERIVE_CHAIN keys
Альтернатива: warmup cascade (replay M1 bars через cascade) — але буде повільніше
Rail: після warmup перевірити buffer fill per TF → log/warning якщо порожній
S3 — Unified prime_ready

m1_poller публікує свій prime_ready (M1/M3 priming status) в окремий Redis key
Supervisor gate: чекає AND(connector_ready, m1_ready) або timeout
Або: connector прймує ВСІ TF (включно M1/M3), а m1_poller не прайміть Redis → простіше
Рішення потребує ADR-like обговорення
S4 — Adaptive priming budget

Замість global timer 5s → per-symbol budget (наприклад 0.5s per symbol)
Або: прибрати timer, додати max total time (30s) і per-TF priority
D1/H4 прайміть першими (менше барів, найважливіші для cold-load)
S5 — Process isolation

Замість crash-all → per-process restart з backoff
Критичні: connector + m1_poller (без них нема даних)
Non-критичні: tick_publisher, tick_preview (live preview, не SSOT)
UI: restart on crash, but health-check endpoint
S6 — Broker-down boot resilience

connector _cold_start_base_from_broker(): timeout + skip on error → degrade-but-loud
m1_poller: вже поводиться добре (skip tail_catchup, reconnect в loop)
Rail: status endpoint показує broker connectivity + bootstrap state
S7 — Config SSOT для bootstrap параметрів

Перемістити hardcoded: prime_ready_timeout=20s, _WARMUP_BARS_BY_TF, _COLD_START_BARS_BY_TF
Додати: bootstrap_max_duration_s, prime_budget_per_symbol_s

1) РЕКОМЕНДОВАНИЙ ПОРЯДОК ВИКОНАННЯ

Phase A (P0 — безпека): S1 + S2
  → Bootstrap не crashує систему; DeriveEngine працює з першої хвилини

Phase B (P1 — координація): S3 + S4 + S6
  → Unified gate; адекватний прайм; broker-down resilience  

Phase C (P2 — операційна якість): S5 + S7
  → Process isolation; config SSOT

Якщо GO — починаємо з S1 (error isolation)? Це найкритичніший slice: зараз один corrupt файл або network glitch = вся платформа down.
