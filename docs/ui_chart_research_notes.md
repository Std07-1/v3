# Дослідження: UI/чарт, скрол, кеш, stitching, SMC

## 1) Visible range / logical range (як у TV)

### Спостереження

- Lightweight Charts дає два ключові сигнали: видимий логічний діапазон (logical range) і видимий часовий діапазон (time range).
- Logical range оперує індексами барів у серії (плаваючі значення), а не абсолютним часом.
- Для TV-подібної поведінки потрібні стабільні правила:
  - чітка конвертація logical -> bar index -> open_time_ms,
  - стабільне відновлення visible range після додавання старих барів.

### Рекомендована модель

- Зберігати бари у масиві зі зростанням open_time_ms.
- Мапа open_time_ms -> index для швидкого доступу.
- Коли додаємо старі бари зліва, збільшуємо logical range на +N, щоб візуально залишатись у тому самому місці.
- Вводити debounce/RAF для реакції на зміни visible range.

### Ризики

- При частому setData можливі "стрибки" діапазону.
- Якщо logical range нечисловий або частково null, потрібно fail-safe режим.

## 2) Моделі API та stitching чанків без повного setData

### Проблема

- Повний setData на кожну порцію створює "стрибки" і важкий рендер.

### Модель 1: Append-only + left-prepend

- Живі апдейти: updateLastBar / update (append) без setData.
- Старі бари: додаємо зліва (prepend) і оновлюємо серію.
- Щоб не ламати UX: після prepend зсунути visible range на +N.

### Модель 2: Окремі "шари" серій

- Основна серія: live/поточний період.
- Фоновий шар: історія зліва (як buffer), який зливається раз на кілька порцій.

### API контракти

- /api/bars?to_open_ms=... для скролу вліво (force_disk).
- /api/bars?since_open_ms=... для дозавантаження вперед.

## 3) Prefetch + гістерезис для scroll і zoom

### Prefetch

- Мета: зняти перший cold-load при перемиканні символу.
- Варіанти:
  - Prefetch Redis tail (швидко, але неглибоко).
  - Prefetch disk (повна історія, але важче).

### Гістерезис

- Scrollback trigger не повинен спрацьовувати при кожному пікселі.
- Рекомендації:
  - Trigger: logicalRange.from < threshold.
  - Мін-інтервал між запитами 1-2s.
  - Single-inflight для скролу.

## 4) UI-кеші (hot/warm/cold), LRU/TTL

### Рівні

- Hot: поточний (symbol, tf) у пам'яті.
- Warm: обмежена кількість (symbol, tf) у Map (LRU).
- Cold: disk (SSOT JSONL).

### Політика

- LRU за ключем (symbol, tf).
- TTL optional (напр. 10-30 хв) для уникнення застарілих state.
- Гарантія: якщо дані є у warm, показуємо одразу + інкрементальні апдейти.

## 5) Стабілізація рендеру

### Рекомендації

- Single-inflight для load/scrollback.
- Cancel або latest-wins для запитів (AbortController).
- Коалесинг запитів: якщо вже є запит на scrollback, не запускати новий.
- Після кожного механізму зміни даних зберігати стан кешу.

### Анти-патерни

- Повний setData у tight loop.
- Неконтрольоване додавання старих барів без корекції visible range.

## 6) Заділ під SMC-шар

### Вхідні вимоги

- Стабільний потік подій (upsert events) з інваріантами: ключ (symbol, tf, open_ms).
- Canonical time (epoch ms) і final>preview політика.

### Інтеграція

- SMC-агрегація має бути окремою серією з власним update API.
- Не змішувати обчислення SMC з UI-шаром; UI лише рендер.
- Для SMC потрібні коректні window-дані: скрол вліво має працювати без "дір".

## Питання для сумаризації

- Який рівень prefetch прийнятний по навантаженню?
- Які TF критичні для глибини історії?
- Які інваріанти SMC вважаємо must-have на старті?
