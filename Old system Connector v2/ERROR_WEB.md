# ERROR_WEB.md

## Baseline v2 (без графіка)

- Стан: працюють summary, таблиці структури/OTE/pools/zones, live-стрім через WebSocket; жодної графіки.
- Мета: мати стабільну точку відкату на випадок проблем із новим чартом.
- Ризик: мінімальний (лише фіксація стану).
- Як перевірити:
  1. `set UI_V2_ENABLED=1` та запустити `python -m app.main` у корені.
  2. `cd UI_v2/web_client` та `python -m http.server 9000`.
  3. Відкрити `http://127.0.0.1:9000/index.html?symbol=xauusd` та переконатися, що відображаються таблиці й працює WS-статус.

## Фаза 1.1 — dev_chart_playground.html (ex chart_demo)

- Що зроблено: додано окрему сторінку `dev_chart_playground.html` (раніше `chart_demo.html`) без змін основного `index.html`; новий контейнер `#chart-container`, контролі символу/таймфрейму, статусний блок.
- Стилі: у `styles.css` додано селектори `.chart-demo-panel`, `.chart-demo-container`, `.chart-demo-status` для темного блоку висотою ~450px.
- Ризик: низький (працює окремо, головний UI не торкається).
- Як запустити playground:
  1. `set UI_V2_ENABLED=1` та `python -m app.main`.
  2. `cd UI_v2/web_client` і `python -m http.server 9000`.
  3. Відкрити `http://127.0.0.1:9000/dev_chart_playground.html?symbol=xauusd`.

## Фаза 1.2 — chart_adapter.js

- Що зроблено: створено `chart_adapter.js` з фабрикою `createChartController(container)` (ініціалізує lightweight-charts, додає candlestick series).
- Реалізовано: `setBars()` і `updateLastBar()` реально оновлюють серію; решта методів поки заглушки (логують виклики).
- Мета: ізолювати роботу з lightweight-charts, щоб інші скрипти лише передавали дані.
- Ризик: низький, прикріплено лише до демо-сторінки.

## Фаза 1.3 — chart_demo.js

- Що зроблено: демо-клієнт читає `symbol` із query, викликає `GET /smc-viewer/ohlcv`, конвертує бари у формат `createChartController` і викликає `setBars`.
- Додано селект таймфрейму (поки 1m) та статус "Bars loaded N / Error".
- Ризик: ізольований playground, не торкається основного UI.
- Smoke-чек:
  1. Запустити backend як вище.
  2. Відкрити `dev_chart_playground.html?symbol=eurusd`.
  3. Має з'явитися свічковий графік на 500 барів; статус показує кількість завантажених барів.

## Фаза 2.1 — overlay API в chart_adapter.js

- Що зроблено: `chart_adapter.js` тепер реально відмальовує SMC оверлеї: `setEvents()` → маркери на свічках, `setLiquidityPools()` → price lines із підписами EQH/EQL/…, `setRanges()` → area-серії min/max, `setOteZones()` і `setZones()` → пари ліній різних кольорів.
- Навіщо: основний UI має отримати універсальний API для побудови всього SMC-контенту без дублювання логіки lightweight-charts; саме тому адаптер навчився очищати попередні шари, створювати area-series та price-lines (див. [UI_v2/web_client/chart_adapter.js](UI_v2/web_client/chart_adapter.js)).
- Код: у згаданому файлі створено масиви `rangeSeries`, `oteLines`, `zoneLines`, додано `clearRanges`, `clearOteZones`, `clearZones`, а також реальні імплементації `setEvents`, `setLiquidityPools`, `setRanges`, `setOteZones`, `setZones`.
- Перед кожним застосуванням шари очищаються (`removePriceLine`, `setMarkers([])`, видалення area-series).
- Очікувані формати:
  - `setEvents([{ time: 1765403519, type: "BOS", direction: "LONG", price: 4227.7 }])`
  - `setLiquidityPools([{ price: 4230.1, role: "PRIMARY", type: "EQH" }])`
  - `setRanges([{ min: 4210, max: 4240, start_time: 1765402000, end_time: 1765405600 }])`
  - `setOteZones([{ min: 4220, max: 4230, label: "LONG OTE" }])`
- Ризик: низький, усе виконується лише на демо-сторінці.

## Фаза 2.2 — SmcViewerState → overlay

- Що зроблено: у `chart_demo.js` (використовується лише в dev-пісочниці) додано `fetchViewerState(symbol)` і функції мапінгу (`mapEventsFromViewerState`, `mapPools…`, `mapOteZones…`, `mapRanges…`, `mapZones…`). Після завантаження OHLCV демо підтягує останній `SmcViewerState` та передає масиви в адаптер.
- Навіщо: потрібно довести, що адаптер може живитися реальним `SmcViewerState`, щоб уникнути ручних моків перед інтеграцією в боєвий UI; таким чином перевірено всю трасу `snapshot → мапери → chart_adapter`.
- Код: у [UI_v2/web_client/chart_demo.js](UI_v2/web_client/chart_demo.js) з'явилися `fetchViewerState`, `normalizeTimestamp`, мапери для кожного шару та виклики `chartController.setEvents/pools/ranges/ote/zones` після завантаження даних.
- Приклад (фрагмент `SmcViewerState.structure.events`):

  ```json
  {
    "structure": {
      "events": [{
        "ts": 1765403519000,
        "type": "BOS",
        "direction": "LONG",
        "price": 4227.7
      }],
      "ote_zones": [{ "ote_min": 4220.5, "ote_max": 4231.2, "direction": "LONG" }]
    },
    "liquidity": {"pools": [{"price": 4235.0, "role": "PRIMARY", "type": "EQH"}]},
    "zones": {"raw": {"zones": [{"price_min": 4212, "price_max": 4218, "type": "OB"}]}}
  }
  ```

  → виклики `setEvents`, `setOteZones`, `setLiquidityPools`, `setZones` з масивами, нормалізованими у секундах.
- Ризик: середній (демо звертається до `/smc-viewer/snapshot?symbol=…`, але головний UI не змінювався).

### Діагностика демо (листопад 2025)

- **Симптом:** демо показувало «Очікуємо…», бо не отримувало дані з бекенда. Дії: відкрити DevTools → Console/Network і перевірити успішність запитів `http://127.0.0.1:8080/smc-viewer/ohlcv` та `…/snapshot?symbol=xauusd`. Якщо бачимо 404/500/timeout — фіксуємо трасу; важливо переконатися, що `python -m app.main` запущено з `UI_V2_ENABLED=1` і процес активний.
- **Перевірка backend:** демо й основний UI споживають один бекенд. Якщо в логах HTTP-сервера лише статичні файли, значить браузер не відправив `/smc-viewer/…` (CORS, блокування, неактивний `127.0.0.1:8080`). Тому обов'язково дивимося Network tab і помилки JS.
- **Причина порожнього графіка:** браузер заблокував CDN lightweight-charts через некоректний `integrity` hash, тож бібліотека не завантажилась і скрипти падали.
- **Фікс:** у [UI_v2/web_client/dev_chart_playground.html](UI_v2/web_client/dev_chart_playground.html#L1-L200) видалено `integrity/crossorigin` з підключення lightweight-charts та залишено робочий варіант:

  ```html
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  ```

  Після `Ctrl+F5` демо завантажує графік і оверлеї; 404 на `favicon.ico` ігноруємо.

## Фаза 3.1 — графік в основному UI

- Що зроблено: у [UI_v2/web_client/index.html](UI_v2/web_client/index.html) додано картку «Price Chart» із контейнером `#chart-container`, CDN lightweight-charts та підключення `chart_adapter.js`; у [UI_v2/web_client/styles.css](UI_v2/web_client/styles.css#L1-L400) з'явився блок `.card-chart` (аналогічні відступи/фон, висота 420px).
- Логіка: [UI_v2/web_client/app.js](UI_v2/web_client/app.js#L1-L400) тепер створює `chartController` після `DOMContentLoaded`, кешує його в `appState.chart` і одразу після `fetchOhlcv()` пушить бари через `chartController.setBars()`; `renderAll()` викликає `updateChartFromViewerState()` для оверлеїв (мапери перенесено з демо).
- Захист: якщо `chartController` відсутній, таблиці продовжують працювати (перевірка з логом `console.warn`), тобто падіння скрипта не блокує решту UI.
- Ризики: середній — тепер основний UI залежить від lightweight-charts CDN; при проблемі чарт просто не з'явиться, але решта елементів живі.
- Як перевірити:
  1. `set UI_V2_ENABLED=1` та `python -m app.main`.
  2. `cd UI_v2/web_client` та `python -m http.server 9000`.
  3. Відкрити `http://127.0.0.1:9000/index.html?symbol=xauusd` і переконатися, що зверху таблиць показується чарт з 500 барами, події/OTE/зони з’являються після отримання snapshot.
  4. (Необов'язково) тимчасово відключити CDN у DevTools → таблиці мають залишитися працездатними.

## Фаза 4.1 — live-оновлення чарта через WS

- Що зроблено: у [UI_v2/web_client/app.js](UI_v2/web_client/app.js#L1-L650) додано `maybeUpdateChartFromWs` — WS handler після оновлення `appState.latestStates` викликає цю функцію, яка читає `viewer_state.ohlcv_last_bar` (або суміжні поля) й передає його у `chartController.updateLastBar`, а також оновлює оверлеї, якщо зміниться `payload_seq`/`payload_ts`. Для цього додано `normalizeOhlcvBar`, `extractLastBarFromViewerState` та трекінг `chartState.overlaySeqBySymbol`.
- Частота: кожен payload WebSocket-а (1–3 сек для XAUUSD) оновлює останню свічку; оверлеї перерендерюються лише коли приходить новий `payload_seq`, тому шуму від ідентичних повідомлень немає.
- Ризики/обмеження:
  - якщо бекенд не передає `payload_seq`, оверлеї оновлюватимуться на кожен WS-пакет (немає маркеру ідемпотентності);
  - при зміні таймфрейму через refetch (`fetchOhlcv`) треба робити повний `setBars` (вже робиться вручну) — якщо користувач переключить символ, попередні price-lines можуть залишитись, поки не прийде новий snapshot;
  - потенційне задвоєння барів можливе, якщо бекенд повертає `time` у секундах, а `setBars` вже записав мс → guard є в `normalizeOhlcvBar`, але потрібно стежити за форматом.
- Як перевірити:
  1. Запустити UI, відкрити `index.html?symbol=xauusd`.
  2. У DevTools → WS frames переконатися, що приходить `payload_seq`; графік має підрухуватись без повного рефрешу сторінки.
  3. Для тесту зупинити backend → остання свічка зупиниться, але історія й оверлеї залишаться.

## Фаза 5.1 — кастомний легенд-блок та перемикачі шарів

- Що зроблено: у [UI_v2/web_client/index.html](UI_v2/web_client/index.html#L1-L140) додано компактний блок `chart-layer-controls` із чекбоксами `BOS/CHOCH`, `Pools`, `OTE`, `Zones`. Він одночасно слугує легендою (кольорові крапки відповідають реальним кольорам шарів). Стилі прописані в [UI_v2/web_client/styles.css](UI_v2/web_client/styles.css#L150-L260) — фон прозорий на 60%, бейджі не перевантажують макет.
- Логіка: [UI_v2/web_client/app.js](UI_v2/web_client/app.js#L150-L360) тримає `chartState.layersVisibility`. Тумблер одразу викликає `updateChartFromViewerState(..., force=true)` або `clearChartLayer`, тому прихований шар повністю зникає з графіка. Паралельно в [UI_v2/web_client/chart_adapter.js](UI_v2/web_client/chart_adapter.js#L70-L150) вимкнено `axisLabelVisible` для price-line, аби не дублювати підписів.
- Навіщо: прибрати громіздкі стандартні ярлики на правій осі та дати трейдеру керувати шумом (наприклад, залишити тільки BOS/CHOCH + OTE).
- Ризики/обмеження:
  - при зміні таймфрейму toggle-стани зберігаються (навіть після перезавантаження сторінки вони скидаються — поки без localStorage);
  - якщо бекенд не віддає `payload_seq`, примусове оновлення при кожному кадрі може короткочасно миготіти при масовому перемиканні.
- Як перевірити:
  1. Оновити UI, увімкнути/вимкнути «Pools» — жовті price-lines мають зникати/з'являтися без перезавантаження сторінки.
  2. Переключити пару тумблерів одночасно й переконатися, що остання свічка продовжує рухатися (WS live оновлення не блокується).
  3. Перевірити, що на правій осі більше немає товстих фонів — усі підписи живуть лише в легенді.

### Dev playground статус

- `dev_chart_playground.html` лишаємо як dev-утиліту для експериментів із `chart_adapter.js`; він не входить у прод-потік і не імпортується `index.html`.
- Канонічний шлях для графіка: [index.html](UI_v2/web_client/index.html) → [app.js](UI_v2/web_client/app.js) → [chart_adapter.js](UI_v2/web_client/chart_adapter.js). Усі бойові зміни потрібно робити саме тут, після перевірки у playground’і.
- README (`UI_v2/web_client/README.md`) містить пояснення, як запускати playground і що він не впливає на користувацький UI.

## Фаза 5.2 — UX: zoom/pan/auto-scale

- Що зроблено: у [UI_v2/web_client/chart_adapter.js](UI_v2/web_client/chart_adapter.js#L1-L160) розширено `DEFAULT_CHART_OPTIONS` (handleScroll/handleScale) — тепер зум колесом, pinch, drag-панорамування та double-click reset працюють із коробки. Тайм-скейл показує реальні хвилини (`timeVisible`) і тримає невеликий `rightOffset`, а price-scale має `autoScale` з комфортним `scaleMargins`.
- Стилі: [UI_v2/web_client/styles.css](UI_v2/web_client/styles.css#L210-L240) додає `cursor: grab/grabbing`, `touch-action: none`, щоб панорамування виглядало природно й не виділяло текст.
- Авто-fit: `chart.timeScale().fitContent()` викликається при початковому `setBars`, тож після завантаження або зміни таймфрейму користувач одразу бачить увесь діапазон; при live-оновленнях `updateLastBar` зберігає ручний зум.
- Ризики: ручний зум скидається після чергового `setBars` (наприклад, при повторному `fetchOhlcv`), що очікувано; якщо потрібно зберігати view між перезавантаженнями, доведеться додати локальний state (поза цим етапом).
- Як перевірити: прокрутити колесо миші над графіком (зум), затиснути ЛКМ/тач і відпустити (пан), натиснути подвійно на вісь для reset. Межі по ціні мають відступи, без обрізання свічок.

## Фаза 5.3 — кастомний price-axis zoom + вертикальний пан

- **Що реалізовано:**
  - у [chart_adapter.js](UI_v2/web_client/chart_adapter.js) додано ручний контролер діапазону ціни: колесо над правою віссю масштабує навколо позиції курсора, Shift+wheel панорамить діапазон, простий drag по полотну після короткої вертикальної «ініціалізації» переводить графік у режим вертикального пану; double-click по осі скидає масштаб.
  - в адаптері зберігаємо `manualRange`, підміняємо `autoscaleInfoProvider`, оновлюємо діапазон через `chart.timeScale().setVisibleLogicalRange`, щоб зміни одразу попадали в рендер без миготіння.
  - стилі [styles.css](UI_v2/web_client/styles.css) отримали стан `vertical-pan-active` (курсор-grabbing), аби користувач розумів, що вмикнено вертикальний drag.
- **Візуальні оверлеї:**
  - BOS/CHOCH тепер малюються не тільки маркерами, а й невеликими симетричними трикутниками (V-подібні ребра + горизонтальна база) у відповідному кольорі (`CHOCH` — помаранчевий, `BOS` — зелений). Трикутники масштабуємо від середнього бару, щоб вони були читабельні на будь-якому TF.
  - OTE зони відображаються парою горизонтальних ліній (верх/низ), підписом на осі (`LONG/SHORT OTE`) та стрілкою, що вказує очікуваний напрям. LONG-зона — м'яка зелень, SHORT — коралова. Увесь рендер тримаємо в `setOteZones`, а очищення — через `clearOteOverlays`, аби тумблери працювали без артефактів.
- **З чого починали:** перша версія підписувала `wheel` + Shift-gestures, але вертикальне перетягування вимагало натиснутого Shift і блокувало стандартний horizontal-pan → користувач бачив інверсію та «стрілку вгору/вниз» замість руки.
- **Проміжні проблеми:**
  - drag без фільтрації одразу перекривав горизонтальний скрол; у певних положеннях `manualRange` залишався активним і коліщатко переставало масштабувати по ціні (брав останній «ручний» діапазон як фіксований);
  - підрахунок відстані мав обернений знак, тож графік рухався у протилежному напрямі, що сприймалось як «інверсія».
- **Фінальна стабілізація:**
  - запроваджено стан `pending → active`, який вмикає вертикальний пан тільки після явного вертикального жесту (>6 пікселів і домінує над горизонтальним). Завдяки цьому звичайне горизонтальне перетягування не блокується, а вертикальний drag включається лише тоді, коли реально потрібен.
  - напрямок пану синхронізовано з рухом курсора (позитивний `deltaY` зсуває діапазон вниз), тому відчуття відповідає TradingView.
  - після завершення drag очищаємо `manualRange`, якщо його не торкались, і скидали прапор pending/active, тож колесо знову працює у двох режимах (price zoom на осі, time zoom всередині).
- **Як тестувати:**
  1. Оновити сторінку, покрутити колесо над правою віссю — має масштабувати лише ціну, над таймскейлом все ще працює горизонтальний zoom.
  2. Потягнути графік по горизонталі — все без змін.
  3. Зробити невеликий вертикальний жест (≈1 см) — курсор зміниться на «руку», графік піде вгору/вниз; відпустити кнопку й переконатися, що колесо знову працює на осі.
  4. Увімкнути/вимкнути шари Events та OTE — пересвідчитись, що трикутники та зони зникають/з'являються без фантомних серій.

## Фаза 5.4 — діагностика BOS та спрощення OTE (2025-12-11)

- **Проблема:** після попередньої ітерації графік іноді зникав одразу після появи, а BOS/CHOCH трикутники перемикались хаотично. Причина — `setEvents()` відмальовував лише останні n подій будь-якого типу, тому коли стрім присилав службові meta-події, реальні BOS/CHOCH витіснялись і трикутники не створювались.
- **Рішення:** фільтруємо список подій до структури (`BOS`/`CHOCH`) перед обмеженням `maxEvents`, отже трикутники тепер зʼявляються навіть якщо payload містить додаткові події. Маркери та таблиця залишаються синхронізованими, бо в UI ми теж показуємо тільки структуру.
- **Друга проблема:** «хвіст» OTE-стрілок (кілька х line-series) створював дані з інверсним порядком часу при вузькому вікні, тому lightweight-charts скидав усі серії, і графік повністю зникав після наступного payload.
- **Рішення:** прибрали вертикальну стрілку і зберегли лише горизонтальні межі зони + підпис на осі. В `setOteZones()` тепер створюються тільки дві лінії (min/max) і price label, тож жодних додаткових серій, які могли б порушити auto-scale.
- **Як перевірити:** перезавантажити UI, увімкнути шар Events — BOS/CHOCH зʼявляться як маркери та трикутники. Потім увімкнути/вимкнути OTE, пересвідчившись, що залишаються тільки акуратні горизонтальні лінії з підписом без «хвостів», і графік не зникає після нових payload-ів.

## Фаза 5.5 — Таймфрейми 1m/5m, fixed symbol та яскраві BOS (2025-12-11)

- **Що додали:** у шапці поруч із селектором символів зʼявився селектор таймфрейму (`1m`/`5m`). Обидва значення (symbol/tf) тепер зберігаються у `localStorage`, тож навіть після F5 UI відкривається з останнім вибором. Автоматичні перезавантаження (snapshot refresh, WS reconnect) більше не скидають ні актив, ні таймфрейм — зміни відбуваються виключно вручну.
- **Захист від сміття:** `normalizeTimeframe()` приймає лише whitelisted значення, тому бекенд не отримає некоректний `tf`, а при зчитуванні з `localStorage` значення одразу санітуються. Якщо збережений символ відсутній у новому snapshot (когорта «мульти-аккаунт»), UI автоматично повертається до дефолтного, але не чіпає інші налаштування.
- **BOS видимість:** структуральні трикутники отримали більш яскраві кольори (`#4ade80` для BOS, `#facc15` для CHOCH), ширші ребра (3px), базу 2px та динамічну висоту (мінімум на рівні 0.06% від ціни). Додатково для кожної події створюється axis label на правій шкалі (`BOS LONG`, `CHOCH SHORT`), тож подію видно навіть якщо сам трикутник поза кадром.
- **Як перевірити:** переключити таймфрейм на `5m`, переконатися, що блок «OHLCV Debug» і графік відображають 5хв дані, перезавантажити сторінку (F5) — UI має відкритися з тими самими symbol+tf. Увімкнути шар Events і переконатися, що біля осі праворуч зʼявляються мітки `BOS/CHOCH`, а трикутники зайняли значну частку діапазону навіть на 5хв.
