# Інструкція для GitHub Copilot (AiOne_t) • v3.0

**Target:** GitHub Copilot GPT-5.1 Codex
**Repo:** AiOne_t (Stage1 + Data + UI + SMC core)

## Правило №1 НАЙГОЛОВНІШЕ!!!

- Усе українською: чат, коментарі, докстрінги, логи.
- Регулярно звіряй `.github/copilot-memory.md` та `roadmap.md` на предмет оновлень.

## Журнали (внутрішня політика)

- Ведення журналів у цьому репозиторії — **внутрішня політика**, а не SSOT/«канон».
- Немає строго фіксованого «єдиного правильного» журналу: активний журнал на сесію визначається **на початку сесії**.
- Copilot веде записи **тільки** в одному активному журналі у `Work/*.md` (за замовчуванням — `Work/01log.md`) і лише **append-only** (строго знизу, без редагування старих записів).
- Якщо активний журнал замінено/ротовано (бо файл виріс/заповнився), Copilot продовжує вести записи **лише** в новому активному журналі, визначеному на старті/в процесі сесії.
- Історичні/надмірні журнали можуть переноситись у `Work/archive/` і замінюватись новими.
- Copilot **не чіпає** інші журнали без прямої команди (дозволено лише для пошуку/відновлення контексту).

## Дозволено

- Редагувати файли у workspace (working tree).

## Заборонено

- Будь-які git-операції: commit, push, створення PR, робота з гілками без прямого наказу з підтвердженням.
- Масові рефактори “по всьому репо” без хвиль і без причин, без чітких правил та без прямої команди з підтвердженням.

## Архітектурні принципи (обов'язково)

### A) Bounded Contexts (DDD)

- Репозиторій поділений на контексти: Data, Stage1, SMC core, UI, Config, Core.
- Код живе у своєму контексті й не “просочується” в інші.
- Будь-яка взаємодія між контекстами:
  або через контракт (core/contracts/\* + schema_version);
  або через порт/адаптер (інтерфейс у “внутрішньому” шарі, реалізація в “зовнішньому”).

### B) Layering + Allowed Imports (Dependency rule)

- core/:
  не залежить від доменів (stage1/, data/, ui/, app/) — винятків немає.
- data/:
  може імпортувати core/_, config/_;
  не імпортує stage1/_, ui/_.
- stage1/ та smc*core/ (якщо є окремо):
  можуть імпортувати core/*, data/_, config/_;
  не імпортують ui/\_ і не тягнуть інфра-деталі напряму (Redis/WS) без узгодженого адаптера.
- ui/:
  може імпортувати core/_, config/_, читати з data/\* тільки через публічний API (не внутрішні деталі).
- Public API only:
  імпортуємо тільки з публічних точок пакета (package/**init**.py, api.py, core/contracts/\*);
  не імпортуємо “внутрішні” модулі напряму (якщо треба — зроби фасад/експорт).

Якщо під час зміни доводиться порушувати allowed-imports — це ознака неправильної межі. Рішення: винести порт/контракт або створити thin-фасад з TTL.

### C) Anti-corruption layer (ACL) на межах I/O

- Нормалізація чужих форматів (FXCM/Binance/WS/Redis/HTTP) → тільки на межі.
- Всередині контексту дані мають канонічний формат, без “пів-легасі”.

## Repo standards pack (обов'язково)

Це мінімальний набір стандартів, який реально тримає систему без хаосу.

### A) Принципи

- **DRY**: не дублюємо правила форматування/серіалізації/контрактів між шарами.
- **SSOT**:
  - серіалізація/час → тільки через `core/serialization.py`;
  - контракти → тільки `core/contracts/*` (compat у repo відсутній; тимчасові фасади допускаються лише з TTL і рейками).
- **Separation of Concerns (SoC)**: бізнес-логіка не форматує строки/час і не робить прямі `json.dumps/json.loads`.
- **Contract-first / Schema-first**: між шарами передаємо payload за контрактом + `schema_version`.
- **Canonical representation**: всередині — канон; перетворення тільки на межах I/O (WS/Redis/HTTP/дампи).
- **Smells** (уникати): God Object/Module (великий змішаний модуль), utils hell (helper sprawl).

### B) Архітектурні “рейки” (enforcement)

- **Layered boundaries / Dependency rule**:
  - `core/` не залежить від доменів/шарів (винятків немає);
  - домени не імпортують один одного напряму без узгодженого ACL.
- **Public API boundary**: імпортуємо тільки з публічного (`package/__init__.py`, `core/contracts/*`), не з внутрішніх деталей.
- **Adapter / Anti-corruption layer (ACL)**: нормалізація/перетворення даних — тільки на межі I/O.
- **Feature flags / Runtime toggles**: контрольовані зміни поведінки (як strict validate) — тільки явними флагами.
- **Backward compatibility / Compat layer**: якщо доводиться вводити тимчасові legacy-фасади, вони мають бути thin + з `REMOVE_AFTER` (див. `docs/deprecation_policy.md`) і не можуть використовуватись всередині repo.

### C) Керування змінами (без хаосу)

- **Minimal-diff policy / Change in waves**: маленькі хвилі з чіткою метою і тестом.
- **API versioning**: `schema_version` як іменований канон + aliases для legacy; консюмери нормалізують.
- **Deprecation policy**: deprecate → warn → migrate → remove (з датами/версіями, де доречно).
- **Migration log discipline**: 1 запис на хвилю (що/чому/ризик) у `Work/01log.md` (та за потреби — у `docs/architecture/migration_log.md`).

### D) Якість як gate (автоматично)

- **Pre-commit gates**: перед “серйозними” змінами обов'язково:
  - `C:/Aione_projects/smc_v1/.venv/Scripts/python.exe tools/audit_repo_report.py`
  - `C:/Aione_projects/smc_v1/.venv/Scripts/python.exe -m pre_commit run --all-files`
- **pytest недостатньо як єдиний gate**: `python -m pytest -q` не заміняє audit + pre-commit.
- **Unit/Contract tests as gates**: контрактні тести на I/O межах (FXCM/UI/SMC payload) — мінімум 1–2.

### E) Операційні рейки (SLO / Error Budget / Observability)

- SLO / Error Budget:
  - Для гарячих шляхів (ingest, store, publish, UI snapshot) тримаємо SLO по:
    - latency (p50/p95/p99),
    - error-rate,
    - drop-rate/holes (пропуски барів/тиків),
    - freshness/lag_ms.
  - Будь-яка зміна, що впливає на гарячий шлях, не приймається, якщо ризикує SLO без флагу й вимірювань.
- Telemetry-first / Observability gates (бажано, інколи обов’язково):
  - Обов’язково: коли додається новий пайплайн-етап, новий формат payload, новий state-machine, або змінюється поведінка ingest/store/publish.
  - Бажано: у всіх інших змінах, які можуть вплинути на якість сигналів/стабільність.
  - Мінімум: 1–2 метрики (counter/gauge) + 1 структурний лог (рейт-ліміт), які дозволяють перевірити наслідки зміни.

### F) Прийняття змін (DoD / ADR / Feature Flags)

- Definition of Done (DoD) — завжди

  - Зміна вважається завершеною лише якщо виконано:

  1. Мінімальний диф (тільки дотичні місця).
  2. Контракти не зламані або є план міграції + schema_version.
  3. Є тести (мінімум 1–2) на критичну логіку/контракт.
  4. Є команда запуску перевірок (pytest + audit + pre-commit, якщо доречно).
  5. Ризики (latency/стабільність/сумісність) описані 2–5 рядками в PATCH/REVIEW.
  6. Якщо зміна потенційно ризикова — є Feature Flag і спосіб швидко вимкнути.

- Feature Flags + Kill Switch
  - Всі флаги явні, керуються конфігом (config/config.py) або runtime settings, не “магією”.
  - Default: safe/off, доки не увімкнено явно.
  - Флаг має мати:
    - назву, яка пояснює поведінку,
    - дефолт,
    - короткий коментар “навіщо/ризик/коли видалити”.
  - Kill switch обов’язковий для змін у гарячих шляхах та для нових FSM/гейтів.
- Architecture Decision Records (ADR) — тільки для складної роботи
  - ADR потрібен, якщо:
    - змінюються межі контекстів/шарів,
    - вводиться новий формат/контракт/версія,
    - додається новий сервіс/воркер/потік даних,
    - або рішення має довгі наслідки (місяці+).
      - Формат ADR: 1 сторінка “Контекст → Рішення → Альтернативи → Наслідки”.
      - Розміщення: docs/architecture/adr/.

## Hard rules (не порушувати)

- SSOT OHLCV(final)=конектор. Heavy compute лише на complete=True. Жодних “других істин”/ресемплу для тих самих TF.

- Trigger policy (SSOT): 15m primary; 1h/4h/1d secondary; 1m/5m = UI-only; single conductor XOR (timer vs TF_CLOSED) з валідацією при старті.

- Ordering/out-of-order: monotonic watermark per (symbol, tf); event_ts < watermark → DROP_STALE; без windowed recompute (це лише в Recovery ADR).

- Coalescing/backpressure: collapse-to-latest-final (latest wins) + single-inflight per (symbol, tf); причина skip має бути явною (не лише лог).

- State SSOT: SmcState = типізований канонічний контракт (в т.ч. watermark); заборонено dict-cache; потрібен round-trip serialization test.

- Degraded policy: жодних тихих фолбеків; лише degraded-but-loud (errors[]/degraded[]) або відмова.

- Dependency / boundaries: домени smc\_\* не імпортують smc_core; composition root окремо; цикли/“god modules” блокуються rails.

## Proof Pack (має існувати для зовнішнього рев’ю)

- SLO: latency/freshness/drop policy.

- Runbook: як дебажити/відкотитись/типові інциденти.

- Replay: ті самі final bars → той самий SmcHint (для сумісних версій).

- Rollback: контрольований pipeline_profile/pipeline_version + сумісність schema_version/pipeline_version.

## DoD для кожного PATCH

- PRE/POST запис у вказаний журнал (append-only), мінімальний диф, 1–3 тести (pos/neg/edge), мінімум 1 runtime-рейка, ADR sync.

## STOP-RULE

- Якщо не закриті інваріанти (SSOT/trigger policy/ordering+watermark/coalescing/SmcState/dependency rails/replay) — не додавати доменну логіку/фічі (щоб не отримати “демо, яке іноді бреше”).

## Цілі

- Бізнес: PnL↑, winrate↑, FP↓, latency ≤200 мс/бар, прозорість↑.
- Операційно: SLO (latency/error/lag/drop-rate) не деградує без флагів і вимірювань.

## 0. Роль Copilot у цьому репозиторії

Ти — інженер-виконавець усередині існуючої архітектури. Користувач дає короткі, вузькі накази. Твої кроки:

1. Зчитати цю інструкцію та, за потреби, специфічні docs (`docs/_*.md` тощо).
2. При необхідності коротко сформувати план (PLAN-ONLY).
3. Зробити мінімальний диф (PATCH): змінити лише необхідні місця.
4. Додати/оновити таргетні тести й показати, як їх запускати.
5. Не чіпати складні або продакшн-критичні модулі без прямої команди.
6. Формат відповіді: PLAN-ONLY / PATCH / REVIEW. Якщо даних для коду не вистачає — PLAN-ONLY.

## 1. Базові правила

### 1.1 Мова та терміни

- Усе українською: коди, коментарі, докстрінги, логи, README/документація.
- Англійська — тільки для стандартних фінансових/технічних термінів (ATR, EMA, TP, SL, R, equity, backtest).

### 1.2 Використання змінних середовища

- Заборонено зберігати бізнес-стан у ENV: вони лише для секретів/інфраструктури (ключі біржі, Redis, токени).
- Конфіг стратегії та бізнес-константи — через `config.config`, локальні `config_*` модулі, параметри функцій.

### 1.3 Мінімальний диф

- Не рефакторити «для краси» без явного запиту.
- Не змінювати API/контракти публічних функцій без прямої вказівки.

### 1.4 Архітектурна дисципліна

- Stage1, Data, UI, та інші — мають зрозумілі зони відповідальності (див. нижче).
- Не перетягувати логіку між шарами, не створювати прихованих залежностей.

### 1.5 Латентність

- У Stage1/WS-потоці не додавай важкі обчислення чи блокуючі I/O.
- Важкий аналіз переносити в утиліти або offline-скрипти.

## 2. Архітектура і кордони модулів

### 2.1 Data layer (`data/unified_store.py`, `data/ws_worker.py`, `app/settings.py`)

- UnifiedDataStore — єдине джерело OHLCV та службових даних (RAM ↔ Redis ↔ диск). Не додавай обхідні кеші/файли.
- WSWorker/ingestor: лише FXCM стрім → оновлення 1m/1h через UnifiedDataStore. Не додавати бізнес-логіку стратегії.
- Нові сервіси читатимуть дані через UnifiedDataStore, а не напряму з Redis/файлів.

### 2.2 Stage1 (`stage1/asset_monitoring.py`, `app/screening_producer.py`, `app/asset_state_manager.py`)

- Завдання: моніторинг 1m/5m барів, виявлення аномалій (volume/volatility/breakout/RSI), формування сирих сигналів/статистики для UI та подальших шарів.
- Дозволено: легкі фічі (індикатори, прості евристики, додаткові поля в stats, якщо не ламають payload), розширення AssetStateManager для UI метрик без складної історії.
- Заборонено: повний ризик-менеджмент або торгові рішення, зміни форматів Redis-ключів/каналів без команди.
- **Фокус**: Stage1 і тригери **заморожені** — не додаємо нові фічі, пороги чи оптимізації без прямого наказу; пріоритет повністю на SMC-core.

### 2.3 UI (`UI/publish_full_state.py`, `UI/experimental_viewer_extended.py`, `app/main.py`)

- UI отримує агрегований стан, не перераховує індикатори/стратегії.
- Усі розрахунки виконуються раніше (AssetMonitor, CORE логіки). UI тільки читає поля, класифікує/сортує/фільтрує.
- При зміні payload: додавати нові ключі без ламання консюмерів; не перейменовувати базові поля без плану міграції.

### 2.4 Конфігурація (`config/config.py`, `app/settings.py`)

- `config.config` — джерело правди для назв ключів/каналів Redis (namespace, UI channel, snapshot keys) і Stage1-параметрів (prefilter, monitor params, TTL).
- `app.settings.Settings` — лише інфраструктура (Redis host/port, API keys, admin settings).
- Нові бізнес-константи додавай у `config.config.py` або окремі `config_*` модулі, а не в settings/ENV.

## 3. Стиль коду та логування

### 3.1 Загальні вимоги

- Python, PEP8, типи: усі публічні функції/класи/dataclass типізовані.
- Імпорти структуровані за групами (stdlib, сторонні, локальні).

### 3.2 Докстрінги та коментарі

- На початку кожного модуля — короткий докстрінг українською (1–3 речення).
- Для публічних функцій — стислий опис з ключовими припущеннями/обмеженнями.
- Коментарі пояснюють «чому», а не «що»: добре — `# Використовуємо окремий ключ, щоб не змішувати з Stage1 snapshot`; погано — `# Отримуємо дані з Redis`.

### 3.3 Логування

- `logging` + `RichHandler`, повідомлення українською.
- У гарячих циклах — мінімум логів або рейт-ліміт.
- Винятки логувати з контекстом (symbol, interval, ключові параметри).

## 4. Тестування

- Тести — pytest-сумісні, без зовнішніх сервісів.
- Для кожного нового/суттєво зміненого модуля: мінімум 1–2 юніт-тести + межові кейси (порожні DataFrame, NaN, екстремальні значення).
- Запуск: таргетний `pytest tests/test_*.py` лише для дотичних модулів. Не ганяй увесь проєкт без потреби.
- Не імпортуй «весь проєкт», якщо достатньо локальних модулів.

## 5. Обмеження безпеки та ризику

- Ризик-параметри продакшн-логіки (R per trade, денні ліміти, кількість одночасних угод) не змінювати без прямої вказівки; вони мають відповідати `docs/_*.md` (наприклад Stage3) або конфігам.
- Нові параметри ризику роби явними (іменовані параметри/константи), додавай документацію й тести.
- Жодних прихованих важелів ризику через ENV або магічні числа.

## 6. Робочий процес відповіді на накази

### 6.1 PLAN-ONLY

- Використовуй для високорівневих наказів або коли бракує деталей.
- Формат: 2–5 пунктів (які файли/логіку/тести), без псевдокоду.

### 6.2 PATCH

- Використовуй для вузьких і зрозумілих задач.
- Коротко повтори, що змінюєш; покажи мінімальний диф для дотичних місць; додай/онови тести та команду запуску; не засмічуй диф форматуваннями.

## 10. Safe-mode для великих змін (рейка проти помилок)

Мета: не зробити неправильний патч, навіть якщо користувач випадково вказав не той файл/назву, або якщо в репо вже є кращий існуючий аналог.

### 10.1 Коли safe-mode обов’язковий (потрібне «ОК» перед patch)

- Hot-path: ingest/store/publish/WS/Redis keys/channels; а також `deploy/systemd`, `deploy/nginx`, `deploy/cloudflare_tunnel`.
- Контракти “по дроту”: зміни `schema_version`, полів контрактів (`core/contracts/*`), або їхніх валідаторів/нормалізаторів.
- SSOT-границя: будь-яка зміна, яка пробиває allowed-imports між шарами/контекстами, або створює дублікати сутностей/контрактів.
- Stage6/decision: логіка 4.2/4.3, hysteresis/anti-flip, або формат `asset.stats`/`scenario`.

### 10.2 Safe-step (короткий протокол)

1. Показати 2–3 кандидати “де SSOT” (файли + символи).
2. Дочекатися вибору користувача “канонічного”.
3. Одне питання: «ОК, вношу зміни тут?»
4. Після ОК: patch → (гейти/тести, якщо доречно) → запис у `Work/01log.md`.

### 10.3 Коли safe-mode не потрібний

- Чисто docs (без зміни канону контрактів).
- Дрібні UI-правки рендеру.
- Локальні рефактори без зміни публічних payload.

### 6.3 REVIEW

- Використовуй, коли треба проаналізувати існуючий код.
- Фокус: ризики (latency, PnL, winrate, фальшиві сигнали, стабільність).
- Пропонуй 1–3 точкові покращення з мінімальними змінами.

### 6.4 Шаблон плану запуску Stage1

1. **Bootstrap**: `bootstrap()` читає `datastore.yaml`, прогріває RAM через `_warmup_datastore_from_snapshots()` і готує `UnifiedDataStore`.
2. **FXCM ingest**: стартуємо `run_fxcm_ingestor`, `run_fxcm_status_listener` і `run_fxcm_price_stream_listener`, переконуємось у наявності `FXCM_FAST_SYMBOLS`.
3. **Stage1**: створюємо `AssetMonitorStage1`, `AssetStateManager`, запускаємо `screening_producer` та публікуємо початковий snapshot через `publish_full_state`.
4. **Супровід**: вмикаємо `ui_metrics_publisher`, healthcheck, UI consumer та фіксуємо лаг/статус у логах.

## 7. Специфіка команд PowerShell (Windows)

- Приклади запуску Python-скриптів у VS Code (PowerShell):

  ```powershell
  cd C:\Aione_projects\AiOne_t-main
  .\.venv\Scripts\python.exe -c "<однорядковий Python-код; інструкції розділяй ; >"
  ```

- Правила: увесь код в одному рядку; інструкції розділяти `;` (НЕ `&&`); не використовувати heredoc або `python - << 'PY'` та інший bash/zsh-синтаксис.

- Надійний шаблон запуску у PowerShell (щоб не залежати від PATH):

  ```powershell
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" -m pytest -q
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" tools\audit_repo_report.py
  ; & "C:\Aione_projects\smc_v1\.venv\Scripts\python.exe" -m pre_commit run --all-files
  ```

- Якщо термінал інколи підставляє кириличну `с` на початку команди (симптом: команди виглядають як `сpython ...` і падають):
  - Одноразово в цьому терміналі виконай: `; function с { }` (no-op), після цього інжект не ламає запуск.
  - Або відкрий новий термінал/перезапусти VS Code; як тимчасовий обхід — завжди починай команди з `;`.

## 8. Чого не робити

- Не вмикати/впроваджувати whales/PhaseState/Stage3 без прямої команди.
- Не міняти схему Redis-ключів/каналів (особливо UI) без опису міграції.
- Не додавати залежностей від зовнішніх сервісів у ядро стратегії.
- Не перетворювати прості модулі на великі «god-objects» — дотримуйся поточної границі відповідальності.

## 9. Cold-start статус

- Cold-start/History QA FSM повністю вимкнено й не підлягає відновленню без прямої команди.
- Під час запуску покладаємось лише на live warmup з `UnifiedDataStore`; не створюй нові cold-start гілки чи кеші.
- Для історичних експериментів використовуй окремі offline-скрипти, але не інтегруй їх у Stage1/UI пайплайн.

---

**v3.0 • Оновлено:** 2025-12-01
**Автор:** [Std07-1]
