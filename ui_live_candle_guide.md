# UI Live‑свічка з тикових оновлень (усі TF)

## Мета
Надати короткий практичний опис, як у UI візуалізувати «живу» свічку для будь‑якого таймфрейму (TF), використовуючи тики в реальному часі, **без** збереження цих live‑барів у SSOT/історію.

## Принципи
1. **SSOT історія — тільки для бекфілу.** Live‑бар не пишемо в store.
2. **Єдине джерело live‑стану — тики.** Live‑бар формується з тикових оновлень у пам’яті.
3. **Агрегація від M1.** Будь‑який TF отримує live‑бар як агрегат поточного M1‑бару або напряму з тиків (рекомендовано: M1 → TF).
4. **UI оновлює тільки останню свічку.** Історичні свічки не переписуються.

## Мінімальна модель live‑бару
Рекомендований контракт live‑бару (приклад полів):
- `tf` — таймфрейм (наприклад, `m1`, `m5`, `h1`).
- `start_ts` — старт інтервалу (ms).
- `end_ts` — кінець інтервалу (ms, не включно).
- `open`, `high`, `low`, `close` — поточні значення.
- `last_price` — остання ціна тіку.
- `last_tick_ts` — ts останнього тіку (ms).
- `is_final` — завжди `false` для live‑бару.

## Як формувати live‑бар з тика
### 1) Прив’язка до інтервалу TF
Для заданого TF із шириною $
\Delta$ (в ms) рахуємо:

$$
start\_ts = \left\lfloor \frac{tick\_ts}{\Delta} \right\rfloor \cdot \Delta
$$

`end_ts = start_ts + Δ`.

### 2) Ініціалізація
Якщо live‑бар відсутній або tick належить новому інтервалу:
- `open = high = low = close = last_price = tick_price`.
- `last_tick_ts = tick_ts`.

### 3) Оновлення
На кожному тіку:
- `close = tick_price`.
- `high = max(high, tick_price)`.
- `low = min(low, tick_price)`.
- `last_price = tick_price`.
- `last_tick_ts = tick_ts`.

## Агрегація M1 → вищі TF
Рекомендовано підтримувати live‑бар **M1** як первинний, і будувати live‑бар TF = k·M1:
- `start_ts_tf = floor(start_ts_m1 / (k·Δ_m1)) * (k·Δ_m1)`.
- `open_tf` — `open` першої M1‑свічки в поточному TF‑вікні.
- `high_tf` — `max(high)` серед M1‑свічок у вікні.
- `low_tf` — `min(low)` серед M1‑свічок у вікні.
- `close_tf` — `close` останньої M1‑свічки у вікні.

Переваги: єдина логіка для всіх TF, стабільні межі, простий UI‑пулінг.

## UI‑практики (малювання)
1. **Оновлюємо лише останню свічку** у серії (останній bar index).
2. **HUD‑ціна**: показувати `last_price` поверх графіка (або поруч з останньою свічкою).
3. **Стабільна вісь часу**: не розширювати історію, якщо live‑бар у межах поточного вікна.
4. **Throttle/poll**: 200–1000 ms (залежно від UI). Якщо API віддає `last_tick_ts`, UI може скипати повторні оновлення з тим самим ts.
5. **Гепи тіку**: якщо нових тиків немає, live‑бар залишається з останнім `close`, без «штучних» рухів.
6. **Початок нового інтервалу**: старий live‑бар вважається «final» у UI, новий стартує з `open` першого тіку нового вікна.

## Рекомендації для API / polling
- Окремий endpoint для live‑стану (наприклад, `/api/live`).
- Віддавати мінімальний payload: `tf`, `start_ts`, `end_ts`, `ohlc`, `last_price`, `last_tick_ts`.
- Кешувати на клієнті та оновлювати тільки при зміні `last_tick_ts`.

## Обмеження й ризики
- **Тики можуть не надходити** без активного підключення або прав доступу.
- **Poll‑цикл** додає навантаження; обирайте помірний інтервал.
- **Різні TF** у UI потребують узгоджених меж часу (особливо при переході дня/сесії).

## Що НЕ робимо
- Не записуємо live‑бари в SSOT/історію.
- Не додаємо нових контрактів для збереження.
- Не використовуємо live‑бар для SMC/аналітики — лише візуалізація.

## Підсумок
Live‑свічка — це **тимчасовий візуальний стан**, сформований із тиків. Найстійкіший підхід: підтримувати M1 live‑бар і агрегувати його у всі потрібні TF, а UI лише оновлює останню свічку та HUD‑ціну.
